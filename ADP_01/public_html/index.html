<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>L&ouml;sungsblatt Vorlage</title>
        <!-- morris graph lib -->
        <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/morris.js/0.5.1/morris.css">
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
        <script src="http://cdnjs.cloudflare.com/ajax/libs/raphael/2.1.0/raphael-min.js"></script>
        <script src="http://cdnjs.cloudflare.com/ajax/libs/morris.js/0.5.1/morris.min.js"></script>
        <!-- LaTeX-style equations -->
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
        </script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <!-- tests -->
        <script>
            function assert(value, desc) {
                var li = document.createElement("li");
                li.style.color = value ? "green" : "red";
                li.appendChild(document.createTextNode(desc));
                var list = document.getElementById("results");
                if (!list) {
                    list = document.createElement("div");
                    document.body.appendChild(list);
                }
                list.appendChild(li);
            }
        </script>
    </head>
    <body>
        <h1 id="title">Enes Kaya, Marcel Lange</h1>


        <h2>
            Aufgabe 1
        </h2>
        <p>
            Gegeben seien ein Startpunkt $x \in \mathbb{N}$ und ein Zielpunkt $y \in \mathbb{N}$ auf einer Geraden,
            sowie ein Schrittma&szlig; $d \in \mathbb{N}$. Gesucht ist die Anzahl der Schritte
            $steps(x, y, d) \in \mathbb{N}$, die ben&ouml;tigt werden, um einen Punkt zu erreichen, dessen Wert
            gr&ouml;&szlig;er als $y$ ist.
        </p>

        <p>
            Beispiel: Bei der Eingabe $x = 15$, $y = 80$, $d = 30$ sind drei Schritte n&ouml;tig.
        </p>
        <ol>
            <li>
                Welchen Zeit- und welchen Platzaufwand hat eine naive Implementierung?
            </li>
            <li>
                Implementieren Sie die Methode $steps(x,y,d)$, welche die gesuchte Anzahl der Schritte in Zeitaufwand $O(1)$ und  Platzaufwand $O(1)$ berechnet.
            </li>
        </ol>
        <h2>
            Antwort 1
        </h2>
        <ol>
            <li>
                Zeitaufwand: $O(n)$, Platzaufwand: $O(1)$<br />
                Eine naive Implementierung wird einfach simulieren, nach wievielen Schritten sie vom Start- beim Zielpunkt ankommt.
                Man kann berechnen, nach wievielen Schritten der Zielpunkt erreicht ist: $(y-x)/d$, das w&auml;re f&uuml;r unser Beispiel $(80-15)/30) = 2,1666...$.
                Da es keine Teil-Schritte gibt, muss bei Nachkommastellen aufgerundet werden und so kommen wir für das Beispiel zu den in der Aufgabe genannten drei Schritten.
                Die naive Implementierung w&uuml;rde den Startwert in einer Schleife mit dem Schrittma&szlig; aufaddieren, bis das Ergebnis gr&ouml;&szlig;er als der Zielpunkt ist.
                Bei der Simulation müssen zusätzlich zu den drei vorgegebenen keine neuen (dynamisch allokierten) Speicherbereiche verwendet werden.
                Deshalb entspricht der Zeitaufwand $O(n)$ und der Platzaufwand $O(1)$.
            </li>
            <li>
                Siehe unten.
            </li>
        </ol>
        <h3>
            Implementierung
        </h3>
        <!-- In diesem Element wird der Inhalt des scripts mit der ID ad-1-1-results angezeigt -->
        <pre id="ad-1-1-source"></pre>
        <h3>
            Testergebnisse
        </h3>
        <div id="ad-1-1-results"></div>

        <!-- Code und Tests hier hin -->
        <script id="ad-1-1-code">
            function steps(x, y, d) {
                var start = x;
                var ziel = y;
                var schritt = d;

                if (d <= 0)
                    return "error";
                if (x >= y)
                    return 0;

                return Math.ceil((ziel - start) / schritt);
            }

            function step_naiv(x, y, d) {
                var start = x;
                var ziel = y;
                var schritt = d;

                if (d <= 0)
                    return "error";
                var count_step = 0;
                for (i = start; i < ziel; i = i + schritt) {
                    count_step++;
                }
                return count_step;
            }

            // Tests
            assert(steps(15, 80, 30) === 3, "Beispielaufruf nach Vorgabe");
            assert(steps(150, 91, 30) === 0, "X > Y");
            assert(steps(15, 80, -1) === "error", " d <= 0 ");
            assert(steps(37, 297, 43) === step_naiv(37, 297, 43), "Beide funktionen liefern das gleiche Ergebnis");

            assert(step_naiv(15, 80, 30) === 3, "Beispielaufruf nach Vorgabe");
            assert(step_naiv(150, 91, 30) === 0, "X > Y");
            assert(step_naiv(15, 80, -1) === "error", " d >= 0 ");
        </script>
        <!-- dieser Code zeigt die Implementierung und die Tests an -->
        <script>
            $('pre#ad-1-1-source').html($('#ad-1-1-code').html())
        </script>
        <!-- Aufgabe 2 -->

        <h2>Aufgabe 2</h2>
        <p>Die Fibonacci-Zahlen. Gegeben sei die folgende Funktion:</p>
        <pre>fib(n) = (n&lt;=1) ? 1 : (fib(n-1)+fib(n-2))</pre>
        <ol>
            <li>Implementieren Sie $fib$ direkt (also naiv).</li>
            <li>Bestimmen Sie experimentell den Zeitaufwand von $fib$ und stellen
                Sie das Ergebnis graphisch dar. Geben Sie die gemessene Laufzeitklasse 
                möglichst präzise in der O-Notation an.</li>
            <li>Die Fibonacci Zahlen können auch schneller berechnet werden. 
                Schreiben Sie jetzt zwei verbesserte Funktionen $fib2$ und $fib3$, die 
                rekursiv mit linearem Zeitaufwand ablaufen ($O(n)$).
                <ul>
                    <li>$fib2$ soll memoization verwenden.</li>
                    <li>$fib3$ soll ohne memoization auskommen.</li>
                </ul>
            </li>
            <li>Bestimmen Sie experimentell den jeweiligen Zeitaufwand von $fib2$ und $fib3$ und stellen Sie die Ergebnisse graphisch dar.</li>
            <li>Erläutern Sie, ob und wie sich Ihre Implementierung $fib2$ und $fib3$ im Platzaufwand unterscheiden.</li>
            <li>Implementieren Sie $fib4$ als iterative Version von $fib3$.</li>
        </ol>
        <p>Alle Versionen $fib1$, ... $fib4$ müssen durch Tests abgedeckt sein.</p>
        <h2>Antwort 2</h2>
        <p>Der Zeitaufwand von $fib$ beläuft sich auf ungefähr $O(2^n)$, bzw. etwas weniger.</p>
        <p>
            Der Platzaufwand von $fib2$ unterscheidet sich von $fib3$ insofern, 
            dass für $fib2$ die Werte in einem Array gespeichert werden.
            Dieses Array bleibt auch nach den Methodenaufrufen vorhanden. 
            Dementsprechend wird immer mehr Speicher allokiert.
            Das Array kann dann auch sehr große Zahlen enthalten, was tendenziell
            speicherbelastender sein kann.
            Bei fib3 werden immer nur die drei Übergabeparameter belegt. Dies 
            geschieht jedoch für jeden Aufruf erneut.
            Wir gehen derzeit davon aus, dass $fib2$ einen Platzaufwand von 
            $O(n)$ hat, da im schlimmsten Fall genau $n$ Werte berechnet
            und gespeichert werden müssen. Bei $fib3$ gehen wir ebenfalls davon 
            aus, dass der Platzaufwand linear ansteigt, also auch $O(n)$ beträgt.

        </p>
        <h3>Implementierung</h3>
        <!-- In diesem Element wird der Inhalt des scripts mit der ID ad-1-2-code angezeigt -->
        <pre id="ad-1-2-source"></pre>
        <h3>Testergebnisse</h3>
        <div id="ad-1-2-results"></div>
        <script id="ad-1-2-code">
            // Code
            var counter = 0;

            function fib(n) {
                counter++;
                return n <= 1 ? 1 : fib(n - 1) + fib(n - 2);
            }

            var fib2memory = {};
            function fib2(n) {
                counter++;
                if (n <= 1) {
                    return 1;
                } else {
                    if (n in fib2memory) {
                        return fib2memory[n];
                    } else {
                        var val = fib2(n - 1) + fib2(n - 2);
                        fib2memory[n] = val;
                        return val;
                    }
                }
            }

            function fib3(n) {
                return fib3_rec(n, 0, 1);
            }

            function fib3_rec(n, a, b) {
                counter++;
                return n === 0 ? a + b : fib3_rec(n - 1, a + b, a);
            }

            function fib4(n) {
                var a = 1;
                var b = 1;
                for (i = 0; i < n; i++) {
                    counter++;
                    var c = a + b;
                    a = b;
                    b = c;
                }
                return a;
            }

            function measureCounter(func, param) {
                counter = 0;
                var value = func(param);
                return {value: value, time: counter};
            }

            // Experiments
            var ad_1_2_data_times = [];
            var ad_1_2_data_values = [];
            for (i = 0; i <= 100; i++) {
                var measure_fib = i <= 10 ? measureCounter(fib, i) : {value: undefined, time: undefined};
                var measure_fib2 = measureCounter(fib2, i);
                var measure_fib3 = measureCounter(fib3, i);
                var measure_fib4 = measureCounter(fib4, i);
                ad_1_2_data_times.push({
                    experiment: i,
                    fib: measure_fib['time'],
                    fib2: measure_fib2['time'],
                    fib3: measure_fib3['time'],
                    fib4: measure_fib4['time']
                });
                ad_1_2_data_values.push({
                    experiment: i,
                    fib: measure_fib['value'],
                    fib2: measure_fib2['value'],
                    fib3: measure_fib3['value'],
                    fib4: measure_fib4['value']
                });
            }

            var ad_1_2_data_times2 = [];
            for (i = 0; i <= 100; i++) {
                fib2memory = {};
                var measure_fib = i <= 10 ? measureCounter(fib, i) : {value: undefined, time: undefined};
                var measure_fib2 = measureCounter(fib2, i);
                var measure_fib3 = measureCounter(fib3, i);
                var measure_fib4 = measureCounter(fib4, i);
                ad_1_2_data_times2.push({
                    experiment: i,
                    fib: measure_fib['time'],
                    fib2: measure_fib2['time'],
                    fib3: measure_fib3['time'],
                    fib4: measure_fib4['time']
                });
            }

            var ad_1_2_data_times3 = [];
            for (i = 5000; i >= 1000; i -= 100) {
                var measure_fib2 = measureCounter(fib2, i);
                var measure_fib3 = measureCounter(fib3, i);
                var measure_fib4 = measureCounter(fib4, i);
                ad_1_2_data_times3.push({
                    experiment: i,
                    fib2: measure_fib2['time'],
                    fib3: measure_fib3['time'],
                    fib4: measure_fib4['time']
                });
            }

            // Tests
            assert(ad_1_2_data_times.length === 101, "experiments have collected data");
            assert(typeof (fib) === 'function', "function 'fib' implemented");
            assert(fib(1) === 1, "Test fuer fib(1) = 1");
            assert(fib(5) === 8, "Test fuer fib(5) = 8");
            assert(fib(10) === 89, "Test fuer fib(10) = 89");
            document.write("<br>");

            assert(typeof (fib2) === 'function', "function 'fib2' implemented");
            assert(fib2(1) === 1, "Test fuer fib2(1) = 1");
            assert(fib2(5) === 8, "Test fuer fib2(5) = 8");
            assert(fib2(10) === 89, "Test fuer fib3(10) = 89");
            assert(fib2(77) === 8944394323791464, "Test fuer fib4(77) = 8944394323791464");
            document.write("<br>");

            assert(typeof (fib3) === 'function', "function 'fib3' implemented");
            assert(fib3(1) === 1, "Test fuer fib3(1) = 1");
            assert(fib3(5) === 8, "Test fuer fib3(5) = 8");
            assert(fib3(10) === 89, "Test fuer fib3(10) = 89");
            assert(fib3(77) === 8944394323791464, "Test fuer fib4(77) = 8944394323791464");
            document.write("<br>");

            assert(typeof (fib4) === 'function', "function 'fib4' implemented");
            assert(fib4(1) === 1, "Test fuer fib4(1) = 1");
            assert(fib4(5) === 8, "Test fuer fib4(5) = 8");
            assert(fib4(10) === 89, "Test fuer fib4(10) = 89");
            assert(fib4(77) === 8944394323791464, "Test fuer fib4(77) = 8944394323791464");
        </script>

        <!-- dieser Code zeigt die Implementierung und die Tests an -->
        <script>$('pre#ad-1-2-source').html($('#ad-1-2-code').html())</script>

        <h3>Experimente</h3>
        <p>Laufzeitverhalten im Vergleich</p>
        <p>fib $O(2^n)$</p>
        <p>fib2 $O(1)$</p>
        <p>fib3 $O(n)$</p>
        <p>fib4 $O(n)$</p>
        <div id="ad-1-2-experiments" style="height: 250px;"></div>
        <p>Laufzeitverhalten im Vergleich (memory von fib2 wurde zwischen den Aufrufen ausgehebelt)</p>
        <p>fib $O(2^n)$</p>
        <p>fib2 $O(n)$</p>
        <p>fib3 $O(n)$</p>
        <p>fib4 $O(n)$</p>
        <div id="ad-1-2-experiments2" style="height: 250px;"></div>
        <p>Laufzeitverhalten im Vergleich - Rückwärts</p>
        <p>fib2 $O(1)$</p>
        <p>fib3 $O(n)$</p>
        <p>fib4 $O(n)$</p>
        <div id="ad-1-2-experiments3" style="height: 250px;"></div>
        <p>Funktionsergebnisse</p>
        <p>Dies zeigt das sie alle auf das selbe Ergebnis kommen.</p>
        <p>Nur fib schafft es nicht höhere Werte zu berechnen.</p>
        <div id="ad-1-2-values" style="height: 250px;"></div>
        <script>
            new Morris.Line({
                element: 'ad-1-2-experiments', // ID of the element in which to draw the chart.
                parseTime: false, // do values relate to dates (time)?
                data: ad_1_2_data_times, // Chart data records -- each entry in this array corresponds to a point on the chart.
                xkey: 'experiment', // The name of the data record attribute that contains x-values.
                ykeys: ['fib', 'fib2', 'fib3', 'fib4'], // A list of names of data record attributes that contain y-values.
                labels: ['fib O(2^n)', 'fib2 O(1)', 'fib3 O(n)', 'fib4 O(n)'] // Labels for the ykeys -- will be displayed when you hover over the chart.
            });
            new Morris.Line({
                element: 'ad-1-2-experiments2', // ID of the element in which to draw the chart.
                parseTime: false, // do values relate to dates (time)?
                data: ad_1_2_data_times2, // Chart data records -- each entry in this array corresponds to a point on the chart.
                xkey: 'experiment', // The name of the data record attribute that contains x-values.
                ykeys: ['fib', 'fib2', 'fib3', 'fib4'], // A list of names of data record attributes that contain y-values.
                labels: ['fib O(2^n)', 'fib2 O(n)', 'fib3 O(n)', 'fib4 O(n)'] // Labels for the ykeys -- will be displayed when you hover over the chart.
            });
            new Morris.Line({
                element: 'ad-1-2-experiments3', // ID of the element in which to draw the chart.
                parseTime: false, // do values relate to dates (time)?
                data: ad_1_2_data_times3, // Chart data records -- each entry in this array corresponds to a point on the chart.
                xkey: 'experiment', // The name of the data record attribute that contains x-values.
                ykeys: ['fib2', 'fib3', 'fib4'], // A list of names of data record attributes that contain y-values.
                labels: ['fib2 O(1)', 'fib3 O(n)', 'fib4 O(n)'] // Labels for the ykeys -- will be displayed when you hover over the chart.
            });
            new Morris.Line({
                element: 'ad-1-2-values',
                parseTime: false,
                data: ad_1_2_data_values,
                xkey: 'experiment',
                ykeys: ['fib', 'fib2', 'fib3', 'fib4'],
                labels: ['fib', 'fib2', 'fib3', 'fib4']
            });
        </script>

        <!-- Aufgabe 3 -->
        <h2>Aufgabe 3</h2>
        <p>Verkettete und Sequentielle Listen. Unsere Listen sollen folgende Methoden unterstützen:</p>
        <ul>
            <li>Ein Element vorne anfügen. $cons(x; list)$</li>
            <li>Vorderstes Element zurückgeben. $head(list)$</li>
            <li>Restliste zurückgeben. $tail(list)$</li>
            <li>Länge einer Liste bestimmen. $length(list)$</li>
            <li>Ist die Liste leer? $isempty(list)$</li>
            <li>Ein Element nach n Elementen einfügen. $insert(x; n; list)$
                <ul>
                    <li>Dabei bedeutet nach n = 0 Elementen einfügen, das man das Element am Anfang einfügt.</li>
                    <li>(Klären Sie, was passieren soll, wenn n größer als die Anzahl der Listenelemente ist!)</li>
                </ul>
            </li>
        </ul>
        <ol>
            <li>Implementieren Sie eine einfach verkettete Liste.</li>
            <li>
                Messung des Zeitaufwandes: Wir nehmen plausiblerweise an, dass der Zeitaufwand einer
                Listenoperation in dieser Implementation proportional zur Anzahl der Dereferenzierungen
                ist. Fügen Sie Messung des Zeitaufwandes Hilfsvariablen ein, die mitzählen, wie oft
                Referenzen “verfolgt” wurden. Implementieren Sie Methoden, um diese Zähler abzufragen,
                zurücksetzen usw.
            </li>
            <li>
                Ein ersten Experiment: Fügen Sie nacheinander die Werte i von 1 bis n in eine leere
                Liste ein – jeweils am Anfang der Liste. Bestimmen Sie den Zeitaufwand mit obigen
                Zählern. Ist das gemessene Ergebnis der zu erwartende Wert?
            </li>
            <li>Wie zuvor, nur dass Sie am Ende einfügen.</li>
            <li>
                Noch ein Experiment: Fügen Sie nacheinander die Werte i von 1 bis n in eine leere Liste
                ein, wobei das Element i an eine zufällige Position zwischen 0 und i eingefügt werden
                soll. Führen Sie das Experiment t-mal durch und bestimmen Sie den Mittwelwert für den
                Zeitaufwand.
                Tragen Sie den mittleren Zeitaufwand als Funktion gegen die Anzahl t der Versuche auf.
                Vergleichen Sie die Ergebnisse mit den beiden vorherigen Experimenten!
            </li>
            <li>Implementieren Sie eine sequentielle (Array-basierte) Liste.</li>
            <li>Erweitern Sie Ihre Implementierung der sequentiellen Liste mit geeigneten Zählern zur Bestimmung dest Zeitaufwands der angebotenen Operationen.</li>
            <li>Führen Sie die mit der verketteten Liste durchgeführten Experimente mit der sequentiellen Liste durch.</li>
            <li>Vergleichen Sie die beiden Implementierungsvarianten der Liste anhand der Ergebnisse der oben geforderten Experimente.</li>
        </ol>
        <h2>Antwort 3</h2>
        <h3>Implementierung</h3>
        <!-- In diesem Element wird der Inhalt des scripts mit der ID ad-1-3-code angezeigt -->
        <pre id="ad-1-3-source"></pre>
        <h3>Testergebnisse</h3>
        <div id="ad-1-3-results"></div>
        <script id="ad-1-3-code">
            // Code
            function LinkedList() {
                function LinkedNode(content, nachfolger) {
                    this.content = content;
                    this.nachfolger = nachfolger;
                }

                var listStart = new LinkedNode(null, null);
                var size = 0;

                var refCounter = 0;

                this.cons = function (value) {
                    this.insert(value, 0);
                };

                this.insert = function (value, pos) {
                    if (pos < 0 || pos > size) {
                        alert("Ungültige Stelle");
                    } else {
                        var vorgaenger = listStart;
                        //alert("value: " + value + ", pos: " + pos + ", size: " + size);
                        for (var i = 0; i < pos; i++) {
                            vorgaenger = vorgaenger.nachfolger;
                            refCounter++;
                        }
                        var nachfolger = vorgaenger.nachfolger;
                        vorgaenger.nachfolger = new LinkedNode(value, nachfolger);
                        size++;
                    }
                };

                this.head = function () {
                    return listStart.nachfolger !== null ? listStart.nachfolger.content : null;
                };

                this.tail = function () {
                    if (!this.isEmpty()) {
                        listStart.nachfolger = listStart.nachfolger.nachfolger;
                        size--;
                    }
                    return this;
                };

                this.length = function () {
                    return size;
                };

                this.isEmpty = function () {
                    return listStart.nachfolger === null;
                };

                this.getRefCounter = function () {
                    return refCounter;
                };

                this.resetRefCounter = function () {
                    refCounter = 0;
                };

                this.print = function () {
                    var text = "";
                    var knoten = listStart;
                    while (knoten.nachfolger !== null) {
                        knoten = knoten.nachfolger;
                        text = text + knoten.content + " ";
                    }
                    console.log(text);
                };
            }
            
            function ArrayList(capacity) {
                var capacity = capacity ? capacity : 10;
                var array = new Array(this.capacity);
                var size = 0;

                var refCounter = 0;

                this.cons = function (value) {
                    this.insert(value, 0);
                };

                this.insert = function (value, pos) {
                    if (pos < 0 || pos > size) {
                        alert("Ungültige Position");
                    } else {
                        //alert("value: " + value + ", pos: " + pos + ", size: " + size + ", capacity: " + capacity);
                        if (size >= capacity) {
                            var oldCapacity = capacity;
                            var oldArray = array;
                            capacity = capacity + 10;
                            array = new Array(capacity);
                            for (i = 0; i < oldCapacity; i++) {
                                array[i] = oldArray[i];
                                refCounter++;
                            }
                        }
                        for (var i = size - 1; i >= pos; i--) {
                            array[i + 1] = array[i];
                            refCounter++;
                        }
                        array[pos] = value;
                        size++;
                    }
                };

                this.head = function () {
                    return array[0];
                }

                this.tail = function () {
                    for (var i = 0; i < size; i++) {
                        array[i] = array[i + 1];
                    }
                    array[size] = null;
                    size--;
                    return this;
                };

                this.length = function () {
                    return size;
                };

                this.isEmpty = function () {
                    return this.length() === 0;
                };

                this.getRefCounter = function () {
                    return refCounter;
                };

                this.resetRefCounter = function () {
                    refCounter = 0;
                };

                this.print = function () {
                    var text = "";
                    for (var i = 0; i < size; i++) {
                        text += array[i] + " ";
                    }
                    alert(text);
                };
            }

            // Experiments
            var linkedList_3 = new LinkedList();
            var linkedList_4 = new LinkedList();
            var linkedList_5 = new LinkedList();
            var linkedList_5_1 = new LinkedList();
            var ad_1_3_linked_data = [];
            for (var i = 1; i < 100; i++) {
                linkedList_3.insert(i, 0);
                linkedList_4.insert(i, i - 1);
                linkedList_5.insert(i, Math.floor(Math.random() * i));
                var aufgabe5_mittelwert = 0;
                var iterationen = 10000;
                for (var j = 0; j < iterationen; j++) {
                    linkedList_5_1.insert(i, Math.floor(Math.random() * i));
                    aufgabe5_mittelwert += linkedList_5_1.getRefCounter();
                    linkedList_5_1.resetRefCounter();
                }
                aufgabe5_mittelwert = aufgabe5_mittelwert / iterationen;
                ad_1_3_linked_data.push({
                    experiment: i,
                    aufgabe3: linkedList_3.getRefCounter(),
                    aufgabe4: linkedList_4.getRefCounter(),
                    aufgabe5: linkedList_5.getRefCounter(),
                    aufgabe5_mittelwert: aufgabe5_mittelwert
                });
                linkedList_3.resetRefCounter();
                linkedList_4.resetRefCounter();
                linkedList_5.resetRefCounter();
            }

            var arrayList_3 = new ArrayList();
            var arrayList_4 = new ArrayList();
            var arrayList_5 = new ArrayList();
            var arrayList_5_1 = new ArrayList();
            var ad_1_3_array_data = [];
            for (var i = 1; i < 100; i++) {
                arrayList_3.insert(i, 0);
                arrayList_4.insert(i, i - 1);
                arrayList_5.insert(i, Math.floor(Math.random() * i));
                var aufgabe5_mittelwert = 0;
                var iterationen = 10;
                for (var j = 0; j < iterationen; j++) {
                    arrayList_5_1.insert(i, Math.floor(Math.random() * i));
                    aufgabe5_mittelwert += arrayList_5_1.getRefCounter();
                    arrayList_5_1.resetRefCounter();
                }
                aufgabe5_mittelwert = aufgabe5_mittelwert / iterationen;
                ad_1_3_array_data.push({
                    experiment: i,
                    aufgabe3: arrayList_3.getRefCounter(),
                    aufgabe4: arrayList_4.getRefCounter(),
                    aufgabe5: arrayList_5.getRefCounter(),
                    aufgabe5_mittelwert: aufgabe5_mittelwert
                });
                arrayList_3.resetRefCounter();
                arrayList_4.resetRefCounter();
                arrayList_5.resetRefCounter();
            }


            // Tests
            var testLinkedList1 = new LinkedList();
            assert(testLinkedList1.isEmpty(), "Neue Liste ist leer");
            testLinkedList1.cons(1);
            assert(!testLinkedList1.isEmpty(), "Liste mit einem Element ist nicht leer");
            assert(testLinkedList1.length() === 1, "Länge nach Einfügen von '1': 1");
            assert(testLinkedList1.head() === 1, "Oberstes Element nach Einfügen von '1': 1");
            testLinkedList1.cons(2);
            assert(testLinkedList1.length() === 2, "Länge nach Einfügen von '2': 2");
            assert(testLinkedList1.head() === 2, "Oberstes Element nach Einfügen von '2': 2");
            testLinkedList1.tail();
            assert(testLinkedList1.head() === 1, "Oberstes Element nach Entfernen des vorherigen obersten Elements (2): 1");
            document.write("<br />");

            var testArrayList1 = new ArrayList();
            assert(testArrayList1.isEmpty(), "Neue Liste ist leer");
            testArrayList1.cons(1);
            assert(!testArrayList1.isEmpty(), "Liste mit einem Element ist nicht leer");
            assert(testArrayList1.length() === 1, "Länge nach Einfügen von '1': 1");
            assert(testArrayList1.head() === 1, "Oberstes Element nach Einfügen von '1': 1");
            testArrayList1.cons(2);
            assert(testArrayList1.length() === 2, "Länge nach Einfügen von '2': 2");
            assert(testArrayList1.head() === 2, "Oberstes Element nach Einfügen von '2': 2");
            testArrayList1.tail();
            assert(testArrayList1.head() === 1, "Oberstes Element nach Entfernen des vorherigen obersten Elements (2): 1");
        </script>
        <!-- dieser Code zeigt die Implementierung und die Tests an -->
        <script>$('pre#ad-1-3-source').html($('#ad-1-3-code').html())</script>

        <h3>Experimente</h3>
        <p>LinkedList Experimente</p>
        <div id="ad-1-3-linked-experiments" style="height: 250px;"></div>
        <p>ArrayList Experimente</p>
        <div id="ad-1-3-array-experiments" style="height: 250px;"></div>
        <script>
            new Morris.Line({
                element: 'ad-1-3-linked-experiments', // ID of the element in which to draw the chart.
                parseTime: false, // do values relate to dates (time)?
                data: ad_1_3_linked_data, // Chart data records -- each entry in this array corresponds to a point on the chart.
                xkey: 'experiment', // The name of the data record attribute that contains x-values.
                ykeys: ['aufgabe3', 'aufgabe4', 'aufgabe5_mittelwert'], // A list of names of data record attributes that contain y-values.
                labels: ['Einfügen am Anfang', 'Einfügen am Ende', 'Einfügen Random (Mittelwert)'] // Labels for the ykeys -- will be displayed when you hover over the chart.
            });
            new Morris.Line({
                element: 'ad-1-3-array-experiments', // ID of the element in which to draw the chart.
                parseTime: false, // do values relate to dates (time)?
                data: ad_1_3_array_data, // Chart data records -- each entry in this array corresponds to a point on the chart.
                xkey: 'experiment', // The name of the data record attribute that contains x-values.
                ykeys: ['aufgabe3', 'aufgabe4', 'aufgabe5_mittelwert'], // A list of names of data record attributes that contain y-values.
                labels: ['Einfügen am Anfang', 'Einfügen am Ende', 'Einfügen Random (mittelwert)'] // Labels for the ykeys -- will be displayed when you hover over the chart.
            });
        </script>
    </body>
</html>